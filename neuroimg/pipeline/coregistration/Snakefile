import os
import sys
sys.path.append("../../../")
from neuroimg.pipeline.fileutils import get_freesurfer_dir

"""
export SUBJECTS_DIR=~/hdd/data/neuroimaging/freesurfer_output/

A snakemake file for running reconstructions on the neuroimaging data.

snakemake --dag | dot -Tpdf > dag_pipeline_coregistration.pdf

"""
configfile: "../config/localconfig.yaml"

''' USER DEFINED DIRECTORIES TO STORE FINAL DATA IN ORGANIZED SUBFOLDERS '''
# get the freesurfer patient directory
FS_PATIENT_OUTPUT_DIR = get_freesurfer_dir(config)
FSOUT_MRI_FOLDER = os.path.join(FS_PATIENT_OUTPUT_DIR, "mri")
FSOUT_CT_FOLDER = os.path.join(FS_PATIENT_OUTPUT_DIR, "CT")
#
# subworkflow reconstruction_workflow:
#     workdir:
#         "../reconstruction/"
#     snakefile:
#         "../reconstruction/Snakefile"
#     configfile:
#         "../config/localconfig.yaml"

# First rule
rule all:
    input:
        # FLIRT FSL OUTPUT COREGISTRATION
        CT_IN_T1_NIFTI_IMG_ORIG=expand(os.path.join(FSOUT_CT_FOLDER, "rCT.nii.gz"),
                                    patient_id=config['patients']),
        # mapping matrix for CT to T1
        MAPPING_FILE=expand(os.path.join(FSOUT_CT_FOLDER, "fsl_ct-to-t1_omat.txt"),
                                    patient_id=config['patients']),
        # MAPPED BRAIN MASK TO CT SPACE
        brainmask_inct_file = expand(os.path.join(FSOUT_CT_FOLDER, "brainmask_inct.nii.gz"),
                                    patient_id=config['patients']),
        wm_inct_outputfile_nifti = expand(os.path.join(FSOUT_CT_FOLDER, "wm_in_ct.nii"),
                                    patient_id=config['patients']),

    shell:
        "echo 'done'"


"""
Rule for coregistering .nifit images -> .nifti for T1 space using Flirt in FSL.

E.g. useful for CT, and DTI images to be coregistered
"""
rule coregistert1_ct_to_pre:
    input:
        PREMRI_NIFTI_IMG_MGZ = os.path.join(FSOUT_MRI_FOLDER, "origT1.nii"),
        CT_NIFTI_IMG_MGZ = os.path.join(FSOUT_CT_FOLDER, "CT.nii"),
    output:
        # mapped image from CT -> MRI
        CT_IN_PRE_NIFTI_IMG_ORIGgz = os.path.join(FSOUT_CT_FOLDER, "rCT.nii.gz"),
        # mapping matrix for post to pre in T1
        MAPPING_FILE_ORIG = os.path.join(FSOUT_CT_FOLDER, "fsl_ct-to-t1_omat.txt"),
    shell:
        "flirt -in {input.CT_NIFTI_IMG_MGZ} \
                            -ref {input.PREMRI_NIFTI_IMG_MGZ} \
                            -omat {output.MAPPING_FILE_ORIG} \
                            -out {output.CT_IN_PRE_NIFTI_IMG_ORIGgz};"


"""
Rule for converting brainmask image volume from MGZ to Nifti
"""
rule convert_brainmask_to_nifti:
    # input:
    #     outsuccess_file = os.path.join(FS_PATIENT_OUTPUT_DIR, "{patient_id}_recon_success.txt")
    params:
        brainmask_mgz = os.path.join(FSOUT_MRI_FOLDER, "brainmask.mgz")
    output:
        brainmask_nifti = os.path.join(FSOUT_MRI_FOLDER, "brainmask.nii.gz")
    shell:
        "mri_convert {params.brainmask_mgz} {output.brainmask_nifti};"

"""
Rule to map the brain mask over to the CT space.
"""
rule map_brainmask_to_ct:
    input:
        brainmask_file = os.path.join(FSOUT_MRI_FOLDER, "brainmask.nii.gz"),
        CT_NIFTI_IMG = os.path.join(FSOUT_CT_FOLDER, "CT.nii"),
        # mapping matrix for post to pre in T1
        MAPPING_FILE_ORIG = os.path.join(FSOUT_CT_FOLDER, "fsl_ct-to-t1_omat.txt"),
    output:
        # mapping matrix for post to pre in T1
        MAPPING_FILE = os.path.join(FSOUT_CT_FOLDER, "fsl_brainmask_to_ct_omat.txt"),
        brainmask_inct_file = os.path.join(FSOUT_CT_FOLDER, "brainmask_inct.nii.gz"),
    shell:
        "flirt -in {input.brainmask_file} \
                            -ref {input.CT_NIFTI_IMG} \
                            -omat {output.MAPPING_FILE} \
                            -out {output.brainmask_inct_file};"

rule convert_to_mgz:
    input:
        CT_NIFTI_IMG_ORIG = os.path.join(FSOUT_CT_FOLDER, "CT.nii"),
    output:
        CT_NIFTI_IMG_MGZ = os.path.join(FSOUT_CT_FOLDER, "CT.mgz"),
    shell:
        "mrconvert {input.CT_NIFTI_IMG_ORIG} {output.CT_NIFTI_IMG_MGZ};"


rule convert_coordinate_system:
    input:
        raw_ct_file = os.path.join(FSOUT_CT_FOLDER, "CT.nii.gz"),
        raw_mri_file = os.path.join(FS_PATIENT_OUTPUT_DIR, "origT1.nii"),
        mgz_mri_file = os.path.join(FS_PATIENT_OUTPUT_DIR, "T1.mgz"),
        desikan_orig_file=os.path.join(FS_PATIENT_OUTPUT_DIR, "aparc.a2009s+aseg.mgz"),
        destrieux_orig_file = os.path.join(FS_PATIENT_OUTPUT_DIR, "aparc.a2009s+aseg.mgz"),
        talairach_transform_file = os.path.join(FS_PATIENT_OUTPUT_DIR, "transforms/talairach.xfm"),
    output:
        ras_label_volume=os.path.join(FS_PATIENT_OUTPUT_DIR, "converted_coord_system", "label_{atlas}.RAS.nii.gz"),
        tal_label_volume = os.path.join(FS_PATIENT_OUTPUT_DIR, "converted_coord_system", "label_{atlas}.TAL.nii.gz"),
        ras_std_label_volume=os.path.join(FS_PATIENT_OUTPUT_DIR, "converted_coord_system", "label_{atlas}.RAS.RO.nii.gz"),
        tal_std_label_volume = os.path.join(FS_PATIENT_OUTPUT_DIR, "converted_coord_system", "label_{atlas}.TAL.RO.nii.gz"),
    run:
        if wildcards.atlas == "dk":
            shell("echo 'Running on desikan atlas!';")
            "echo 'mri_convert -rt nearest --out_orientation RAS {input.desikan_orig_file} \
                                                            {output.ras_label_volume}';"
            shell("mri_convert -rt nearest --out_orientation RAS {input.desikan_orig_file} \
                                                            {output.ras_label_volume};")
            shell("mri_convert {input.desikan_orig_file} --apply_transform {input.talairach_transform_file} -oc 0 0 0 {output.tal_label_volume};")

        elif wildcards.atlas == "destrieux":
            shell("echo 'Running on destrieux atlas!'")
            shell("mri_convert -rt nearest --out_orientation RAS {input.destrieux_orig_file} \
                                                            {output.ras_label_volume};")
            shell("mri_convert {input.destrieux_orig_file} --apply_transform {input.talairach_transform_file} -oc 0 0 0 {output.tal_label_volume};")

        shell("fslreorient2std  {output.ras_label_volume} {output.ras_std_label_volume};")
        shell("fslreorient2std {output.tal_label_volume} {output.tal_std_label_volume};")


"""
Rule for robust registration of two volumes within two volumes
"""
rule robust_registration_ct_to_pre:
    input:
        PREMRI_IMG_MGZ = os.path.join(FSOUT_MRI_FOLDER, "orig", "001.mgz"),
        CT_IMG_MGZ = os.path.join(FSOUT_CT_FOLDER, "CT.mgz"),
    output:
        # mapping matrix from CT -> MRI
        output_registration_file = os.path.join(FSOUT_CT_FOLDER, "robustfs_ct-to-t1_omat.txt"),
        # mapped image from CT -> MRI
        output_registration_image = os.path.join(FSOUT_CT_FOLDER, "CT_in_pre_T1_robustregistration.mgz"),
        weights_file = os.path.join(FSOUT_CT_FOLDER, "CT_in_pre_T1_outlierweights.mgz")
    shell:
        "mri_robust_register --mov {input.CT_IMG_MGZ} \
                            --dst {input.PREMRI_IMG_MGZ} \
                            --lta {output.output_registration_file} \
                            --mapmovhdr {output.output_registration_image} \
                            -weights {output.weights_file} \
                            --satit \
                            --iscale;"

